<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Comparison Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .images {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .image-container {
            flex: 1;
            text-align: center;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border: 2px solid #ddd;
            border-radius: 4px;
        }
        .results {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .result-item {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-left: 4px solid #007bff;
            border-radius: 4px;
        }
        .error {
            color: #dc3545;
            background: #f8d7da;
            border-left-color: #dc3545;
        }
        .success {
            color: #155724;
            background: #d4edda;
            border-left-color: #28a745;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .config {
            background: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .config label {
            display: inline-block;
            width: 200px;
            margin: 5px 0;
        }
        .config input {
            width: 100px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Image Comparison Test - pHash & SSIM Analysis</h1>
        <p>Testing the same algorithms used in AutoSlides slide extraction system.</p>

        <div class="config">
            <h3>Configuration (same as slideExtractor defaults)</h3>
            <label>Hamming Threshold Low:</label>
            <input type="number" id="hammingLow" value="0" min="0" max="64"><br>
            <label>Hamming Threshold Up:</label>
            <input type="number" id="hammingUp" value="5" min="0" max="64"><br>
            <label>SSIM Threshold:</label>
            <input type="number" id="ssimThreshold" value="0.999" min="0" max="1" step="0.001"><br>
        </div>

        <div class="images">
            <div class="image-container">
                <h3>Image 1: Slide_1759439556848.png</h3>
                <img id="img1" src="REFERENCE/Slide_1759439556848.png" alt="Slide 1">
            </div>
            <div class="image-container">
                <h3>Image 2: Slide_1759439585765.png</h3>
                <img id="img2" src="REFERENCE/Slide_1759439585765.png" alt="Slide 2">
            </div>
        </div>

        <button onclick="analyzeImages()" id="analyzeBtn">Analyze Images</button>

        <div class="results" id="results">
            <p>Click "Analyze Images" to start the comparison...</p>
        </div>
    </div>

    <script>
        // Same algorithms as in slideProcessor.worker.ts

        function convertToGrayscale(imageData) {
            const data = new Uint8ClampedArray(imageData.data);

            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                data[i] = gray;     // R
                data[i + 1] = gray; // G
                data[i + 2] = gray; // B
                // Alpha remains unchanged
            }

            return new ImageData(data, imageData.width, imageData.height);
        }

        function resizeImageData(imageData, newWidth, newHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;
            const ctx = canvas.getContext('2d');

            // Create temporary canvas for original image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);

            // Resize and draw
            ctx.drawImage(tempCanvas, 0, 0, newWidth, newHeight);

            return ctx.getImageData(0, 0, newWidth, newHeight);
        }

        function applyDCT32x32(pixels) {
            const size = 32;
            const coeffs = [];

            for (let u = 0; u < size; u++) {
                for (let v = 0; v < size; v++) {
                    let sum = 0;
                    for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            const pixel = pixels[(y * size + x) * 4]; // Take R component (grayscale)
                            sum += pixel *
                                   Math.cos((2 * x + 1) * u * Math.PI / (2 * size)) *
                                   Math.cos((2 * y + 1) * v * Math.PI / (2 * size));
                        }
                    }

                    const c_u = u === 0 ? 1 / Math.sqrt(2) : 1;
                    const c_v = v === 0 ? 1 / Math.sqrt(2) : 1;
                    coeffs.push((1 / (size / 2)) * c_u * c_v * sum);
                }
            }

            return coeffs;
        }

        function extractLowFrequencyCoeffs(dctCoeffs) {
            const lowFreqCoeffs = [];

            // Extract top-left 8x8 region from 32x32 DCT coefficient matrix
            for (let u = 0; u < 8; u++) {
                for (let v = 0; v < 8; v++) {
                    const index = u * 32 + v; // Index in 32x32 matrix
                    lowFreqCoeffs.push(dctCoeffs[index]);
                }
            }

            return lowFreqCoeffs;
        }

        function calculateMedian(values) {
            if (values.length === 0) return 0;

            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);

            if (sorted.length % 2 === 0) {
                return (sorted[mid - 1] + sorted[mid]) / 2;
            } else {
                return sorted[mid];
            }
        }

        function calculatePerceptualHash(imageData) {
            if (!imageData) {
                console.warn('calculatePerceptualHash: imageData is null');
                return 0;
            }

            // 1. Convert to grayscale first
            const grayscale = convertToGrayscale(imageData);

            // 2. Resize to 32x32
            const resized = resizeImageData(grayscale, 32, 32);

            // 3. Apply DCT transform to 32x32 grayscale image
            const dctCoeffs = applyDCT32x32(resized.data);

            // 4. Extract top-left 8x8 low frequency region from 32x32 DCT result
            const lowFreqCoeffs = extractLowFrequencyCoeffs(dctCoeffs);

            // 5. Exclude DC component, calculate median of remaining 63 coefficients
            const acCoeffs = lowFreqCoeffs.slice(1); // Exclude DC component
            const median = calculateMedian(acCoeffs);

            // 6. Generate 63-bit hash
            let hash = 0;
            for (let i = 0; i < acCoeffs.length; i++) {
                hash = hash * 2 + (acCoeffs[i] >= median ? 1 : 0);
            }

            return hash;
        }

        function calculateHammingDistance(hash1, hash2) {
            let xor = hash1 ^ hash2;
            let distance = 0;

            while (xor) {
                distance += xor & 1;
                xor >>>= 1;
            }

            return distance;
        }

        function calculateSSIM(img1Data, img2Data) {
            // Convert to grayscale
            const gray1 = convertToGrayscale(img1Data);
            const gray2 = convertToGrayscale(img2Data);

            // Calculate means
            let mean1 = 0, mean2 = 0;
            const pixelCount = gray1.width * gray1.height;

            for (let i = 0; i < gray1.data.length; i += 4) {
                mean1 += gray1.data[i];
                mean2 += gray2.data[i];
            }
            mean1 /= pixelCount;
            mean2 /= pixelCount;

            // Calculate variance and covariance
            let var1 = 0, var2 = 0, covar = 0;
            for (let i = 0; i < gray1.data.length; i += 4) {
                const diff1 = gray1.data[i] - mean1;
                const diff2 = gray2.data[i] - mean2;
                var1 += diff1 * diff1;
                var2 += diff2 * diff2;
                covar += diff1 * diff2;
            }
            var1 /= pixelCount;
            var2 /= pixelCount;
            covar /= pixelCount;

            // Stability constants
            const C1 = 0.01 * 255 * 0.01 * 255;
            const C2 = 0.03 * 255 * 0.03 * 255;

            // Calculate SSIM
            const numerator = (2 * mean1 * mean2 + C1) * (2 * covar + C2);
            const denominator = (mean1 * mean1 + mean2 * mean2 + C1) * (var1 + var2 + C2);

            return numerator / denominator;
        }

        function compareImages(img1Data, img2Data, config) {
            try {
                // Check if input parameters are valid
                if (!img1Data || !img2Data) {
                    console.warn('compareImages: One or both images are null/undefined');
                    return false; // If there are null values, consider no change
                }

                // Level 1: Calculate perceptual hash
                const hash1 = calculatePerceptualHash(img1Data);
                const hash2 = calculatePerceptualHash(img2Data);

                // Calculate Hamming distance
                const hammingDistance = calculateHammingDistance(hash1, hash2);

                if (hammingDistance > config.hammingThresholdUp) {
                    // Hash detected significant change
                    return true;
                } else if (hammingDistance <= config.hammingThresholdLow) {
                    // Hash completely identical
                    return false;
                } else {
                    // Boundary case, use SSIM for precise comparison
                    const ssim = calculateSSIM(img1Data, img2Data);
                    return ssim < config.ssimThreshold;
                }

            } catch (error) {
                console.error('Error in compareImages:', error);
                return false;
            }
        }

        function loadImageAsImageData(img) {
            return new Promise((resolve, reject) => {
                if (img.complete) {
                    processImage();
                } else {
                    img.onload = processImage;
                    img.onerror = () => reject(new Error('Failed to load image'));
                }

                function processImage() {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    resolve(imageData);
                }
            });
        }

        async function analyzeImages() {
            const btn = document.getElementById('analyzeBtn');
            const results = document.getElementById('results');

            btn.disabled = true;
            btn.textContent = 'Analyzing...';
            results.innerHTML = '<p>Processing images...</p>';

            try {
                const img1 = document.getElementById('img1');
                const img2 = document.getElementById('img2');

                // Get configuration
                const config = {
                    hammingThresholdLow: parseInt(document.getElementById('hammingLow').value),
                    hammingThresholdUp: parseInt(document.getElementById('hammingUp').value),
                    ssimThreshold: parseFloat(document.getElementById('ssimThreshold').value)
                };

                // Load images as ImageData
                const img1Data = await loadImageAsImageData(img1);
                const img2Data = await loadImageAsImageData(img2);

                // Calculate hashes
                const hash1 = calculatePerceptualHash(img1Data);
                const hash2 = calculatePerceptualHash(img2Data);

                // Calculate Hamming distance
                const hammingDistance = calculateHammingDistance(hash1, hash2);

                // Calculate SSIM
                const ssim = calculateSSIM(img1Data, img2Data);

                // Determine if images are considered different
                const areImagesDifferent = compareImages(img1Data, img2Data, config);

                // Display results
                let html = '<h3>Analysis Results</h3>';

                html += `<div class="result-item">
                    <strong>Image 1 Dimensions:</strong> ${img1Data.width} × ${img1Data.height}
                </div>`;

                html += `<div class="result-item">
                    <strong>Image 2 Dimensions:</strong> ${img2Data.width} × ${img2Data.height}
                </div>`;

                html += `<div class="result-item">
                    <strong>pHash 1:</strong> ${hash1} (binary: ${hash1.toString(2).padStart(63, '0')})
                </div>`;

                html += `<div class="result-item">
                    <strong>pHash 2:</strong> ${hash2} (binary: ${hash2.toString(2).padStart(63, '0')})
                </div>`;

                html += `<div class="result-item">
                    <strong>Hamming Distance:</strong> ${hammingDistance} bits different
                </div>`;

                html += `<div class="result-item">
                    <strong>SSIM Score:</strong> ${ssim.toFixed(6)} (1.0 = identical, 0.0 = completely different)
                </div>`;

                // Decision logic explanation
                let decisionClass = 'result-item';
                let decisionText = '';

                if (hammingDistance > config.hammingThresholdUp) {
                    decisionClass += ' success';
                    decisionText = `Images are DIFFERENT (Hamming distance ${hammingDistance} > threshold ${config.hammingThresholdUp})`;
                } else if (hammingDistance <= config.hammingThresholdLow) {
                    decisionClass += ' error';
                    decisionText = `Images are SAME (Hamming distance ${hammingDistance} ≤ threshold ${config.hammingThresholdLow})`;
                } else {
                    if (ssim < config.ssimThreshold) {
                        decisionClass += ' success';
                        decisionText = `Images are DIFFERENT (Hamming in boundary range, SSIM ${ssim.toFixed(6)} < threshold ${config.ssimThreshold})`;
                    } else {
                        decisionClass += ' error';
                        decisionText = `Images are SAME (Hamming in boundary range, SSIM ${ssim.toFixed(6)} ≥ threshold ${config.ssimThreshold})`;
                    }
                }

                html += `<div class="${decisionClass}">
                    <strong>Final Decision:</strong> ${decisionText}
                </div>`;

                // Configuration used
                html += `<div class="result-item">
                    <strong>Configuration Used:</strong><br>
                    • Hamming Low: ${config.hammingThresholdLow}<br>
                    • Hamming Up: ${config.hammingThresholdUp}<br>
                    • SSIM Threshold: ${config.ssimThreshold}
                </div>`;

                results.innerHTML = html;

            } catch (error) {
                results.innerHTML = `<div class="result-item error">
                    <strong>Error:</strong> ${error.message}
                </div>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Analyze Images';
            }
        }
    </script>
</body>
</html>