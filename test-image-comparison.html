<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Image Comparison Analysis (Corrected)</title>
    <script src="https://unpkg.com/ssim.js/dist/ssim.web.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; background-color: #f5f5f5; color: #333; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .images { display: flex; flex-wrap: wrap; gap: 20px; margin: 20px 0; }
        .image-container { flex: 1; min-width: 300px; text-align: center; }
        .image-container img { max-width: 100%; height: auto; border: 2px solid #ddd; border-radius: 4px; }
        .results { background: #f8f9fa; padding: 1px 20px 20px; border-radius: 4px; margin: 20px 0; }
        .result-item, .perf-summary { margin: 15px 0; padding: 15px; background: white; border-left: 5px solid #007bff; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .error { color: #dc3545; background: #f8d7da; border-left-color: #dc3545; }
        .success { color: #155724; background: #d4edda; border-left-color: #28a745; }
        .standard-item { border-left-color: #fd7e14; }
        .perf-summary { border-left-color: #6f42c1; }
        h1, h2, h3, h4 { color: #343a40; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-top: 25px;}
        button { background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.2s; }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .loading-spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid #ffffff; border-radius: 50%; border-top-color: transparent; animation: spin 1s ease-in-out infinite; margin-right: 8px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .file-input-wrapper { position: relative; display: inline-block; margin-bottom: 15px; }
        .file-input-wrapper input[type=file] { position: absolute; left: -9999px; }
        .file-input-label { display: inline-block; padding: 10px 20px; background: #28a745; color: white; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s; border: none; }
        .file-input-label:hover { background: #218838; }
        .file-input-label:active { background: #1e7e34; }
        .file-name { display: block; margin-top: 8px; font-size: 12px; color: #666; font-style: italic; }
        .config { background: #e9ecef; padding: 15px; border-radius: 4px; margin: 20px 0; display: flex; flex-wrap: wrap; gap: 20px; align-items: center; }
        .config .threshold-item { display: flex; flex-direction: column; align-items: center; }
        .config label { font-size: 13px; margin-bottom: 5px; text-align: center; font-weight: bold; }
        .config input[type="number"] { width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; text-align: center; }
        .hash-value { word-break: break-all; font-family: monospace; font-size: 12px; line-height: 1.4; background: #f0f0f0; padding: 8px; border-radius: 3px; margin: 8px 0; }
        .warning { color: #856404; background: #fff3cd; border-left-color: #ffc107; }
        #ssimMapContainer canvas { max-width: 100%; border: 1px solid #ccc; margin-top: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced Image Comparison Analysis</h1>
        <p>Comparing custom fast algorithms against standard, independent implementations.</p>

        <h3>Configuration</h3>
        <div class="config">
            <div class="threshold-item"><label>Global SSIM<br>Threshold</label><input type="number" id="ssimGlobalThreshold" value="0.999" min="0" max="1" step="0.001"></div>
            <div class="threshold-item"><label>Standard SSIM<br>Threshold</label><input type="number" id="ssimStandardThreshold" value="0.999" min="0" max="1" step="0.01"></div>
            <div class="threshold-item"><label>pHash 64-bit<br>Threshold</label><input type="number" id="hash64Threshold" value="5" min="0" max="64"></div>
            <div class="threshold-item"><label>pHash 256-bit<br>Threshold</label><input type="number" id="hash256Threshold" value="20" min="0" max="256"></div>
            <div class="threshold-item"><label>pHash 1024-bit<br>Threshold</label><input type="number" id="hash1024Threshold" value="80" min="0" max="1024"></div>
        </div>

        <div class="images">
            <div class="image-container">
                <h3>Image 1</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="img1File" accept="image/*" onchange="loadImage(1)">
                    <label for="img1File" class="file-input-label">Choose File</label>
                    <span class="file-name" id="img1FileName">No file selected</span>
                </div>
                <img id="img1" alt="Image 1" style="display: none;">
            </div>
            <div class="image-container">
                <h3>Image 2</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="img2File" accept="image/*" onchange="loadImage(2)">
                    <label for="img2File" class="file-input-label">Choose File</label>
                    <span class="file-name" id="img2FileName">No file selected</span>
                </div>
                <img id="img2" alt="Image 2" style="display: none;">
            </div>
        </div>

        <button onclick="analyzeImages()" id="analyzeBtn">Analyze Images</button>

        <div class="results" id="results">
            <p>Select two images and click "Analyze Images" to start the comparison...</p>
        </div>
    </div>

    <script defer>
        function loadImage(imageNumber) {
            const fileInput = document.getElementById(`img${imageNumber}File`);
            const imgElement = document.getElementById(`img${imageNumber}`);
            const fileNameElement = document.getElementById(`img${imageNumber}FileName`);

            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                fileNameElement.textContent = file.name;

                const reader = new FileReader();
                reader.onload = e => {
                    imgElement.src = e.target.result;
                    imgElement.style.display = 'block';
                };
                reader.readAsDataURL(file);
            } else {
                fileNameElement.textContent = 'No file selected';
            }
        }
        
        // --- ALGORITHM IMPLEMENTATIONS ---

        function convertToGrayscale(imageData) {
            const data = new Uint8ClampedArray(imageData.data);
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
            return new ImageData(data, imageData.width, imageData.height);
        }

        function resizeImageData(imageData, newWidth, newHeight) {
            const canvas = document.createElement('canvas'); canvas.width = newWidth; canvas.height = newHeight;
            const ctx = canvas.getContext('2d');
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = imageData.width; tempCanvas.height = imageData.height;
            tempCanvas.getContext('2d').putImageData(imageData, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0, newWidth, newHeight);
            return ctx.getImageData(0, 0, newWidth, newHeight);
        }
        
        // YOUR GLOBAL SSIM (Unchanged)
        function calculateGlobalSSIM(img1Data, img2Data) {
            const gray1 = convertToGrayscale(img1Data); const gray2 = convertToGrayscale(img2Data);
            let m1 = 0, m2 = 0; const pc = gray1.width * gray1.height;
            for (let i = 0; i < gray1.data.length; i += 4) { m1 += gray1.data[i]; m2 += gray2.data[i]; }
            m1 /= pc; m2 /= pc; let v1 = 0, v2 = 0, cov = 0;
            for (let i = 0; i < gray1.data.length; i += 4) {
                const d1 = gray1.data[i] - m1; const d2 = gray2.data[i] - m2;
                v1 += d1 * d1; v2 += d2 * d2; cov += d1 * d2;
            }
            v1 /= pc; v2 /= pc; cov /= pc; const C1 = 6.5025, C2 = 58.5225;
            const num = (2 * m1 * m2 + C1) * (2 * cov + C2); const den = (m1 * m1 + m2 * m2 + C1) * (v1 + v2 + C2);
            return num / den;
        }

        // STANDARD SSIM (Wrapper for ssim.js library)
        function calculateStandardSSIM(img1Data, img2Data) {
            if (typeof ssim === 'undefined' || typeof ssim.default !== 'function') {
                throw new Error('ssim.js library not loaded correctly. Please check your internet connection and refresh.');
            }
            if (img1Data.width !== img2Data.width || img1Data.height !== img2Data.height) {
                img2Data = resizeImageData(img2Data, img1Data.width, img1Data.height);
            }
            // CORRECTED: Call ssim.default() as the user pointed out
            return ssim.default(img1Data, img2Data); // Returns { mssim, ssim_map }
        }

        // --- STANDARD PHASH IMPLEMENTATION ---
        function applyDCT(pixels, size) {
            const coeffs = [];
            const pi_div_2s = Math.PI / (2 * size);
            for (let u = 0; u < size; u++) {
                for (let v = 0; v < size; v++) {
                    let sum = 0;
                    for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            sum += pixels[(y * size + x) * 4] * Math.cos((2 * x + 1) * u * pi_div_2s) * Math.cos((2 * y + 1) * v * pi_div_2s);
                        }
                    }
                    const c_u = u === 0 ? 1 / Math.sqrt(2) : 1; const c_v = v === 0 ? 1 / Math.sqrt(2) : 1;
                    coeffs.push((2 / size) * c_u * c_v * sum);
                }
            }
            return coeffs;
        }

        function calculateStandardPerceptualHash(imageData, hashSideDim) {
            const dctSideDim = hashSideDim * 4; // Standard practice: DCT size is 4x the hash dimension (e.g., 8x8 hash uses 32x32 DCT)
            const grayscale = convertToGrayscale(imageData);
            const resized = resizeImageData(grayscale, dctSideDim, dctSideDim);
            const dctCoeffs = applyDCT(resized.data, dctSideDim);
            const lowFreqCoeffs = [];
            for (let u = 0; u < hashSideDim; u++) {
                for (let v = 0; v < hashSideDim; v++) {
                    lowFreqCoeffs.push(dctCoeffs[u * dctSideDim + v]);
                }
            }
            const acCoeffs = lowFreqCoeffs.slice(1);
            const median = calculateMedian(acCoeffs);
            let hash = 0n;
            for (const coeff of acCoeffs) { hash = (hash << 1n) | (coeff >= median ? 1n : 0n); }
            return hash;
        }

        function calculateMedian(values) {
            if (values.length === 0) return 0;
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }

        function calculateHammingDistance(hash1, hash2) {
            let xor = hash1 ^ hash2; let distance = 0;
            while (xor > 0n) { distance += Number(xor & 1n); xor >>= 1n; } return distance;
        }

        // --- VARIANCE OF LAPLACIAN BLUR DETECTION ---
        function calculateVarianceOfLaplacian(imageData) {
            // Convert to grayscale first
            const grayscale = convertToGrayscale(imageData);
            const width = grayscale.width;
            const height = grayscale.height;
            const data = grayscale.data;

            // Laplacian kernel: [[0, -1, 0], [-1, 4, -1], [0, -1, 0]]
            const laplacianValues = [];

            // Apply Laplacian filter (skip border pixels to avoid edge effects)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const center = (y * width + x) * 4;
                    const top = ((y - 1) * width + x) * 4;
                    const bottom = ((y + 1) * width + x) * 4;
                    const left = (y * width + (x - 1)) * 4;
                    const right = (y * width + (x + 1)) * 4;

                    // Apply Laplacian kernel
                    const laplacian = 4 * data[center] - data[top] - data[bottom] - data[left] - data[right];
                    laplacianValues.push(laplacian);
                }
            }

            // Calculate variance of Laplacian values
            if (laplacianValues.length === 0) return 0;

            const mean = laplacianValues.reduce((sum, val) => sum + val, 0) / laplacianValues.length;
            const variance = laplacianValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / laplacianValues.length;

            return variance;
        }

        // --- GRAYSCALE HISTOGRAM ENTROPY ---
        function calculateGrayscaleHistogramEntropy(imageData) {
            // Convert to grayscale first
            const grayscale = convertToGrayscale(imageData);
            const data = grayscale.data;

            // Build histogram (256 bins for grayscale values 0-255)
            const histogram = new Array(256).fill(0);
            const totalPixels = grayscale.width * grayscale.height;

            // Count pixel intensities
            for (let i = 0; i < data.length; i += 4) {
                const grayValue = Math.round(data[i]); // R, G, B are all the same in grayscale
                histogram[grayValue]++;
            }

            // Calculate entropy: H = -Σ(p * log2(p))
            let entropy = 0;
            for (let i = 0; i < 256; i++) {
                if (histogram[i] > 0) {
                    const probability = histogram[i] / totalPixels;
                    entropy -= probability * Math.log2(probability);
                }
            }

            return entropy;
        }

        // --- HIGH-PASS FILTER NOISE DETECTION ---
        function calculateHighPassNoiseLevel(imageData) {
            // Convert to grayscale first
            const grayscale = convertToGrayscale(imageData);
            const width = grayscale.width;
            const height = grayscale.height;
            const data = grayscale.data;

            // High-pass filter kernel (emphasizes rapid changes/noise)
            // Using a 3x3 high-pass kernel: [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]
            const highPassValues = [];

            // Apply high-pass filter (skip border pixels to avoid edge effects)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const center = (y * width + x) * 4;

                    // Get 3x3 neighborhood
                    const neighbors = [
                        ((y - 1) * width + (x - 1)) * 4, // top-left
                        ((y - 1) * width + x) * 4,       // top
                        ((y - 1) * width + (x + 1)) * 4, // top-right
                        (y * width + (x - 1)) * 4,       // left
                        (y * width + (x + 1)) * 4,       // right
                        ((y + 1) * width + (x - 1)) * 4, // bottom-left
                        ((y + 1) * width + x) * 4,       // bottom
                        ((y + 1) * width + (x + 1)) * 4  // bottom-right
                    ];

                    // Apply high-pass kernel: center * 8 - sum of all neighbors
                    let neighborSum = 0;
                    for (const neighborIdx of neighbors) {
                        neighborSum += data[neighborIdx];
                    }

                    const highPassValue = 8 * data[center] - neighborSum;
                    highPassValues.push(Math.abs(highPassValue)); // Use absolute value for noise magnitude
                }
            }

            // Calculate statistics of high-pass response
            if (highPassValues.length === 0) return 0;

            // Use standard deviation of high-pass response as noise measure
            const mean = highPassValues.reduce((sum, val) => sum + val, 0) / highPassValues.length;
            const variance = highPassValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / highPassValues.length;
            const stdDev = Math.sqrt(variance);

            // Return a combination of mean and standard deviation for robust noise estimation
            return mean + stdDev * 0.5; // Weighted combination
        }
        
        function loadImageAsImageData(img) {
            return new Promise((resolve, reject) => {
                const processImage = () => {
                    const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));
                };
                if (img.complete && img.naturalWidth > 0) processImage(); else { img.onload = processImage; img.onerror = () => reject(new Error('Failed to load image')); }
            });
        }

        async function analyzeImages() {
            const btn = document.getElementById('analyzeBtn');
            const results = document.getElementById('results');
            btn.disabled = true;
            btn.innerHTML = '<span class="loading-spinner"></span>Analyzing...';
            results.innerHTML = '<p>Processing, this may take a moment...</p>';

            // Allow UI to update before starting heavy computation
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const totalStartTime = performance.now();
            const timings = {};

            try {
                const img1 = document.getElementById('img1');
                const img2 = document.getElementById('img2');
                if (!img1.src || !img2.src) throw new Error("Please select both images first.");
                
                let startTime = performance.now();
                const img1Data = await loadImageAsImageData(img1);
                timings.img1Load = performance.now() - startTime;
                startTime = performance.now();
                const img2Data = await loadImageAsImageData(img2);
                timings.img2Load = performance.now() - startTime;
                
                // Calculate image quality metrics for display in Image Information
                startTime = performance.now();
                const img1BlurScore = calculateVarianceOfLaplacian(img1Data);
                timings.img1Blur = performance.now() - startTime;

                startTime = performance.now();
                const img2BlurScore = calculateVarianceOfLaplacian(img2Data);
                timings.img2Blur = performance.now() - startTime;

                startTime = performance.now();
                const img1Entropy = calculateGrayscaleHistogramEntropy(img1Data);
                timings.img1Entropy = performance.now() - startTime;

                startTime = performance.now();
                const img2Entropy = calculateGrayscaleHistogramEntropy(img2Data);
                timings.img2Entropy = performance.now() - startTime;

                startTime = performance.now();
                const img1NoiseLevel = calculateHighPassNoiseLevel(img1Data);
                timings.img1Noise = performance.now() - startTime;

                startTime = performance.now();
                const img2NoiseLevel = calculateHighPassNoiseLevel(img2Data);
                timings.img2Noise = performance.now() - startTime;

                let html = `<h4>Image Information</h4>
                    <div class="result-item">
                        <strong>Dimensions:</strong> Image 1: ${img1Data.width}×${img1Data.height} | Image 2: ${img2Data.width}×${img2Data.height}
                    </div>
                    <div class="result-item">
                        <strong>Variance of Laplacian (blur detection):</strong> Image 1: ${img1BlurScore.toFixed(2)} | Image 2: ${img2BlurScore.toFixed(2)}
                        <div style="margin-top: 5px; font-size: 12px; color: #666;">Higher values indicate sharper images</div>
                    </div>
                    <div class="result-item">
                        <strong>High-Pass Noise Level:</strong> Image 1: ${img1NoiseLevel.toFixed(2)} | Image 2: ${img2NoiseLevel.toFixed(2)}
                        <div style="margin-top: 5px; font-size: 12px; color: #666;">Higher values indicate more noise/grain in the image</div>
                    </div>
                    <div class="result-item">
                        <strong>Histogram Entropy:</strong> Image 1: ${img1Entropy.toFixed(3)} bits | Image 2: ${img2Entropy.toFixed(3)} bits
                        <div style="margin-top: 5px; font-size: 12px; color: #666;">Higher entropy indicates more complex/detailed images (max: 8.0 bits)</div>
                    </div>`;

                // --- SSIM Analysis ---
                html += `<h2>SSIM Analysis</h2>`;
                const ssimGlobalThreshold = parseFloat(document.getElementById('ssimGlobalThreshold').value);
                startTime = performance.now();
                const globalSSIM = calculateGlobalSSIM(img1Data, img2Data);
                timings.globalSSIM = performance.now() - startTime;
                const isDiffGlobalSSIM = globalSSIM < ssimGlobalThreshold;
                html += `<div class="result-item ${isDiffGlobalSSIM ? 'success' : 'error'}">
                    <strong>Global SSIM Score:</strong> ${globalSSIM.toFixed(6)} (Thresh: ${ssimGlobalThreshold}) → <strong>${isDiffGlobalSSIM ? 'DIFFERENT' : 'SAME'}</strong>
                </div>`;

                const ssimStandardThreshold = parseFloat(document.getElementById('ssimStandardThreshold').value);
                startTime = performance.now();
                const standardSSIMResult = calculateStandardSSIM(img1Data, img2Data);
                timings.standardSSIM = performance.now() - startTime;
                const isDiffStandardSSIM = standardSSIMResult.mssim < ssimStandardThreshold;
                html += `<div class="result-item standard-item ${isDiffStandardSSIM ? 'success' : 'error'}">
                    <strong>Standard SSIM Score:</strong> ${standardSSIMResult.mssim.toFixed(6)} (Thresh: ${ssimStandardThreshold}) → <strong>${isDiffStandardSSIM ? 'DIFFERENT' : 'SAME'}</strong>
                    <div style="margin-top: 10px; font-size: 13px; color: #666;">
                        <strong>Detailed SSIM Statistics:</strong><br>
                        • Mean SSIM: ${standardSSIMResult.mssim.toFixed(6)}<br>
                        • Map Dimensions: ${standardSSIMResult.ssim_map ? `${standardSSIMResult.ssim_map.width}×${standardSSIMResult.ssim_map.height}` : 'N/A'}<br>
                        • Data Points: ${standardSSIMResult.ssim_map ? standardSSIMResult.ssim_map.width * standardSSIMResult.ssim_map.height : 'N/A'}<br>
                        • Algorithm: Structural Similarity Index with sliding window
                    </div>
                </div>`;


                // --- Standard pHash Analysis ---
                html += `<h2>Standard pHash Analysis</h2>`;
                const pHashMap = [
                    { bits: 64, side: 8, threshold: parseInt(document.getElementById('hash64Threshold').value) },
                    { bits: 256, side: 16, threshold: parseInt(document.getElementById('hash256Threshold').value) },
                    { bits: 1024, side: 32, threshold: parseInt(document.getElementById('hash1024Threshold').value) },
                ];

                for (const p of pHashMap) {
                    startTime = performance.now(); const hash1 = calculateStandardPerceptualHash(img1Data, p.side); timings[`pHash${p.bits}_1`] = performance.now() - startTime;
                    startTime = performance.now(); const hash2 = calculateStandardPerceptualHash(img2Data, p.side); timings[`pHash${p.bits}_2`] = performance.now() - startTime;
                    const ham = calculateHammingDistance(hash1, hash2);
                    const isDiff = ham > p.threshold;
                    html += `<div class="result-item standard-item ${isDiff ? 'success' : 'error'}">
                        <strong>${p.bits}-bit pHash:</strong> Hamming Dist: ${ham} (Thresh: ${p.threshold}) → <strong>${isDiff ? 'DIFFERENT' : 'SAME'}</strong>
                        <div class="hash-value"><strong>Img1 Hash:</strong> ${hash1.toString(16).padStart(p.bits/4, '0')}</div>
                        <div class="hash-value"><strong>Img2 Hash:</strong> ${hash2.toString(16).padStart(p.bits/4, '0')}</div>
                    </div>`;
                }

                const totalDuration = performance.now() - totalStartTime;
                const sumOfCalcs = Object.values(timings).reduce((a, b) => a + b, 0);
                const otherTime = totalDuration - sumOfCalcs;

                html += `<div class="perf-summary">
                    <h3>Performance Breakdown</h3>
                    <ul>
                        <li><strong>Image Data Loading (Img1/Img2):</strong> ${timings.img1Load.toFixed(2)}ms / ${timings.img2Load.toFixed(2)}ms</li>
                        <li><strong>Blur Detection (Img1/Img2):</strong> ${timings.img1Blur.toFixed(2)}ms / ${timings.img2Blur.toFixed(2)}ms</li>
                        <li><strong>Noise Detection (Img1/Img2):</strong> ${timings.img1Noise.toFixed(2)}ms / ${timings.img2Noise.toFixed(2)}ms</li>
                        <li><strong>Histogram Entropy (Img1/Img2):</strong> ${timings.img1Entropy.toFixed(2)}ms / ${timings.img2Entropy.toFixed(2)}ms</li>
                        <li><strong>Global SSIM Calculation:</strong> ${timings.globalSSIM.toFixed(2)} ms</li>
                        <li><strong>Standard SSIM Calculation:</strong> ${timings.standardSSIM.toFixed(2)} ms</li>
                        <hr>
                        <li><strong>Standard pHash 64-bit (Img1/Img2):</strong> ${timings.pHash64_1.toFixed(2)}ms / ${timings.pHash64_2.toFixed(2)}ms</li>
                        <li><strong>Standard pHash 256-bit (Img1/Img2):</strong> ${timings.pHash256_1.toFixed(2)}ms / ${timings.pHash256_2.toFixed(2)}ms</li>
                        <li><strong>Standard pHash 1024-bit (Img1/Img2):</strong> ${timings.pHash1024_1.toFixed(2)}ms / ${timings.pHash1024_2.toFixed(2)}ms</li>
                        <hr>
                        <li><strong>Algorithm Calculations (Sum):</strong> ${(sumOfCalcs - timings.img1Load - timings.img2Load).toFixed(2)} ms</li>
                        <li><strong>Other Overhead (e.g. DOM, Promises):</strong> ${otherTime.toFixed(2)} ms</li>
                    </ul>
                </div>`;

                results.innerHTML = html;


            } catch (error) {
                results.innerHTML = `<div class="result-item error"><strong>Error:</strong> ${error.message}</div>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Analyze Images';
            }
        }
    </script>
</body>
</html>